<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Rotating Christmas Tree</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#020616;}
    #app{position:fixed;inset:0;}
    .tip{
      position:fixed;left:12px;right:12px;bottom:12px;
      color:rgba(255,255,255,.72);
      font:13px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      text-align:center; user-select:none;
      text-shadow:0 8px 18px rgba(0,0,0,.45);
      z-index:2;
    }
    .chip{
      position:fixed;top:12px;left:12px;
      padding:10px 12px;border-radius:999px;
      background:rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.14);
      color:rgba(255,255,255,.85);
      font:13px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:2;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="chip" id="chip">Rotate: On</div>
  <div class="tip">点击屏幕：暂停/继续旋转｜双击：切换转速</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const mount = document.getElementById("app");
const chip  = document.getElementById("chip");

// ---- Scene / Camera / Renderer ----
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x020616, 6, 22);

const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
camera.position.set(0, 2.2, 9.8);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setClearColor(0x020616, 1);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
mount.appendChild(renderer.domElement);

// ---- Lights ----
scene.add(new THREE.AmbientLight(0x2a6cff, 0.55));

const key = new THREE.DirectionalLight(0x8fd3ff, 1.05);
key.position.set(4, 7, 5);
scene.add(key);

const rim = new THREE.DirectionalLight(0x2a6cff, 0.85);
rim.position.set(-6, 4, -6);
scene.add(rim);

// ---- Background "nebula" (simple gradient plane) ----
{
  const bgGeo = new THREE.PlaneGeometry(60, 60);
  const bgMat = new THREE.MeshBasicMaterial({ color: 0x020616 });
  const bg = new THREE.Mesh(bgGeo, bgMat);
  bg.position.z = -18;
  scene.add(bg);
}

// ---- Tree Group ----
const tree = new THREE.Group();
scene.add(tree);

// "glow" material helper (cheap glow-ish)
function glowMat(color, intensity=1.0){
  return new THREE.MeshStandardMaterial({
    color,
    emissive: new THREE.Color(color),
    emissiveIntensity: intensity,
    roughness: 0.35,
    metalness: 0.05
  });
}

// Trunk
{
  const geo = new THREE.CylinderGeometry(0.32, 0.42, 1.35, 20);
  const mat = new THREE.MeshStandardMaterial({ color: 0x3a2416, roughness: 0.9 });
  const trunk = new THREE.Mesh(geo, mat);
  trunk.position.y = -1.5;
  tree.add(trunk);
}

// Tree body (stacked cones for layered look)
{
  const layers = 4;
  for (let i=0;i<layers;i++){
    const t = i/(layers-1);
    const radius = 2.25 - t*0.65;
    const height = 2.25 - t*0.35;
    const geo = new THREE.ConeGeometry(radius, height, 64, 1, true);
    const mat = glowMat(0x2aa9ff, 0.75 - t*0.12);
    mat.transparent = true;
    mat.opacity = 0.92;
    const cone = new THREE.Mesh(geo, mat);
    cone.position.y = -0.2 + i*0.95;
    cone.rotation.y = (i*0.55);
    tree.add(cone);
  }
}

// Tree "ice sparkle" particles around tree
const sparkleCount = 900;
let sparkleGeom, sparkle;
{
  sparkleGeom = new THREE.BufferGeometry();
  const pos = new Float32Array(sparkleCount * 3);
  for (let i=0;i<sparkleCount;i++){
    // distribute in a cone-ish volume
    const y = THREE.MathUtils.lerp(-0.9, 3.2, Math.random());
    const k = (y + 0.9) / (3.2 + 0.9);
    const r = (2.4 - 1.2*k) * Math.sqrt(Math.random());
    const a = Math.random() * Math.PI * 2;
    pos[i*3+0] = Math.cos(a)*r;
    pos[i*3+1] = y;
    pos[i*3+2] = Math.sin(a)*r;
  }
  sparkleGeom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  const mat = new THREE.PointsMaterial({
    color: 0xbfe9ff,
    size: 0.03,
    transparent: true,
    opacity: 0.55,
    depthWrite: false
  });
  sparkle = new THREE.Points(sparkleGeom, mat);
  tree.add(sparkle);
}

// Ornaments (small emissive bulbs)
const bulbs = [];
{
  const bulbGeo = new THREE.SphereGeometry(0.06, 16, 16);
  const colors = [0x7dd3fc, 0xa5b4fc, 0x93c5fd, 0xe9d5ff, 0xffffff];

  for (let i=0;i<90;i++){
    const y = THREE.MathUtils.lerp(-0.6, 2.9, Math.random());
    const k = (y + 0.6) / (2.9 + 0.6);
    const maxR = 2.0 - 1.05*k;
    const r = maxR * (0.25 + 0.75*Math.random());
    const a = Math.random()*Math.PI*2;

    const mat = glowMat(colors[(Math.random()*colors.length)|0], 1.25);
    mat.transparent = true;
    mat.opacity = 0.95;

    const m = new THREE.Mesh(bulbGeo, mat);
    m.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
    tree.add(m);

    bulbs.push({ mesh: m, phase: Math.random()*Math.PI*2, speed: 0.8 + Math.random()*1.8 });
  }
}

// Star (glowing)
let star;
{
  const geo = new THREE.IcosahedronGeometry(0.22, 0);
  const mat = glowMat(0xffffff, 2.2);
  star = new THREE.Mesh(geo, mat);
  star.position.y = 3.35;
  tree.add(star);

  const starLight = new THREE.PointLight(0xbfe9ff, 2.2, 18, 2);
  starLight.position.set(0, 3.35, 0);
  tree.add(starLight);
}

// Ground haze
{
  const geo = new THREE.CircleGeometry(3.6, 64);
  const mat = new THREE.MeshBasicMaterial({ color: 0x0a1a35, transparent: true, opacity: 0.55 });
  const ground = new THREE.Mesh(geo, mat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -2.1;
  scene.add(ground);
}

// Snow (falling points)
const snowCount = 1100;
let snowGeom, snow;
{
  snowGeom = new THREE.BufferGeometry();
  const pos = new Float32Array(snowCount * 3);
  for (let i=0;i<snowCount;i++){
    pos[i*3+0] = THREE.MathUtils.lerp(-10, 10, Math.random());
    pos[i*3+1] = THREE.MathUtils.lerp(-2, 12, Math.random());
    pos[i*3+2] = THREE.MathUtils.lerp(-10, 10, Math.random());
  }
  snowGeom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  const mat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.035,
    transparent: true,
    opacity: 0.7,
    depthWrite: false
  });
  snow = new THREE.Points(snowGeom, mat);
  scene.add(snow);
}

// ---- Resize ----
function resize(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h, false);
}
window.addEventListener("resize", resize);
resize();

// ---- Interaction ----
let rotating = true;
let speedMode = 1; // 0 slow, 1 normal, 2 fast
const speeds = [0.0025, 0.006, 0.012];

function updateChip(){
  chip.textContent = `Rotate: ${rotating ? "On" : "Off"} (${["Slow","Normal","Fast"][speedMode]})`;
}
updateChip();

let lastTap = 0;
window.addEventListener("pointerdown", () => {
  const now = performance.now();
  if (now - lastTap < 320) {
    // double tap: change speed
    speedMode = (speedMode + 1) % 3;
  } else {
    // single tap: toggle rotate
    rotating = !rotating;
  }
  lastTap = now;
  updateChip();
});

// ---- Animate ----
let t = 0;
function animate(){
  requestAnimationFrame(animate);
  t += 0.016;

  // rotate tree
  if (rotating) tree.rotation.y += speeds[speedMode];

  // star pulse
  const pulse = 1.6 + 0.7 * (0.5 + 0.5*Math.sin(t*2.2));
  star.material.emissiveIntensity = pulse;

  // bulbs blink
  for (const b of bulbs){
    const k = 0.9 + 0.9*(0.5 + 0.5*Math.sin(t*b.speed + b.phase));
    b.mesh.material.emissiveIntensity = 0.8 + k;
    b.mesh.scale.setScalar(0.9 + 0.18*k);
  }

  // snow falling
  const arr = snowGeom.attributes.position.array;
  for (let i=0;i<snowCount;i++){
    const idx = i*3+1;
    arr[idx] -= 0.03 + (i%7)*0.002;
    if (arr[idx] < -2.2) arr[idx] = 12.0;
  }
  snowGeom.attributes.position.needsUpdate = true;

  // subtle sparkle drift
  sparkle.rotation.y += 0.0015;

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
